<!DOCTYPE html>
<html lang="ko"
      xmlns:th="http://www.thymleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Comiclub</title>
    <link rel="stylesheet" href="/css/board/detail/viewer.css">
    <link rel="stylesheet" href="/css/reset.css">
    <link rel="stylesheet" href="/css/class_style.css">
    <link rel="stylesheet" href="/css/font.css">
</head>
<body>
    <div id="wrap">
        <header>
            <div class="container">
                <div class="option-box">
                    <div class="option-back option-item" th:onclick="|location.href='/series/${seriesId}'|">
                        <span>&lt</span>
                    </div>
                    <div class="option-title option-item" th:text="${board.title}">제목</div>
                    <div class="view-option option-item">
                        <div class="auto-mode-changer none">
                            <span>자동재생</span>
                            <img src="/img/viewer/playButton.png" />
                        </div>
                        <div class="view-mode-changer">
                            <span>가로모드</span>
                            <img src="/img/viewer/viewModeButton.png" />
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <main th:with="auth=${#authentication.principal != 'anonymousUser'}, principal=${auth ? #authentication.principal : _ }">
            <div class="shower-cont">
                <button class="prev-scene-button none"><img src="/img/prevButtonImg.png" /></button>
                <div class="shower-box vert-mode"></div>
                <button class="next-scene-button none"><img src="/img/nextButtonImg.png" /></button>
            </div>
            <div class="comment-wrap">
                <div class="author-word-box">
                    <h4>작가의 한마디</h4>
                    <p th:text="${board.authorWords}">내용</p>
                </div>
                <div class="comment-cont">
                    <div class="comment-head">
                        <div class="comment-count" th:text="|총 ${board.totalComment}개의 댓글|">총 댓글 수</div>
                        <div class="comment-write-form">
                            <div class="comment-write-area" th:if="${auth}">
                                <div class="comment-write-writer" th:text="${principal.nickname}">작성자</div>
                                <textarea maxlength="1000" spellcheck="false"></textarea>
                                <div style="height: 40px;padding-top: 10px;">
                                    <button class="comment-write-button" style="justify-content: right;" onclick="writeComment()">작성</button>
                                </div>
                            </div>
                            <div class="auth-box" th:if="${!auth}">
                                <a href="/login">로그인</a>후 이용해 주세요
                            </div>
                        </div>
                    </div>
                    <div class="comment-body">
                        <div class="comment-list-box">
                            <ul>
                                <li class="comment-item" th:each="comment : ${page.content}" th:attr="data-id=${comment.id}">
                                    <div class="comment-item-box">
                                        <div class="comment-sub" th:attr="data-id=${comment.id}" onclick="showCommentOption(event)">ㆍㆍㆍ</div>
                                        <div class="comment-option-modal modal none" th:attr="data-id=${comment.id}" >
                                            <div class="option flex justify-content-center align-items-center" th:attr="data-id=${comment.id}" onclick="showModifier(this)">수정하기</div>
                                            <div class="option flex justify-content-center align-items-center" th:attr="data-id=${comment.id}" onclick="deleteComment(this)">삭제하기</div>
                                        </div>
                                        <div class="comment-item-writer" th:text="${comment.writer}">작성자</div>
                                        <div class="comment-item-date" th:text="${{comment.createdDate}}">2023-03-27 23:00</div>
                                        <div class="comment-item-content" th:text="${comment.content}">드디어 돌아왔구나 박태식이 드디어 돌아왔구나 박태식이드디어 돌아왔구나 박태식이드디어 돌아왔구나 박태식이드디어 돌아왔구나 박태식이드디어 돌아왔구나 박태식이드디어 돌아왔구나 박태식이드디어 돌아왔구나 박태식이드디어 돌아왔구나 박태식이드디어 돌아왔구나 박태식이</div>
                                        <div class="modify-box none">
                                            <div class="modify-area">
                                                <textarea maxlength="1000" spellcheck="false"></textarea>
                                            </div>
                                            <div class="flex" style="justify-content: right;">
                                                <button class="mod-apply-button" style="justify-content: right;" th:attr="data-id=${comment.id}" onclick="modifyComment(this)">수정</button>
                                                <button class="mod-apply-button" style="justify-content: right;" th:attr="data-id=${comment.id}" onclick="showModifier(this)">취소</button>
                                            </div>
                                        </div>
                                        <div class="comment-item-option flex">
                                            <div class="comment-item-reply" th:attr="data-id=${comment.id}, data-first=${comment.totalReply == 0 ? 'false' : 'true'}" onclick="showReplies(this)" th:text="|답글 ${comment.totalReply}개|">총 답글 수</div>
                                            <div class="flex grow align-items-center" >
                                                <div class="comment-item-like like-unlike" th:attr="data-id=${comment.id}" onclick="likeComment(this)">
                                                    <img src="/img/likeImg.png">
                                                    <span th:text="${comment.totalLike}">추천 수</span>
                                                </div>
                                                <div class="comment-item-unlike like-unlike" th:attr="data-id=${comment.id}" onclick="unlikeComment(this)">
                                                    <img src="/img/unlikeImg.png">
                                                    <span th:text="${comment.totalUnlike}">비추천 수</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="reply-list-box none" th:attr="data-id=${comment.id}">
                                        <ul>
                                            <div class="reply-write-form flex">
                                                <div class="reply-boundary"></div>
                                                <div class="reply-write-box grow">
                                                    <div class="comment-item-writer" th:if="${auth}" th:text="${principal.nickname}" >작성자</div>
                                                    <div class="reply-write-area" th:attr="data-id=${comment.id}" th:if="${auth}">
                                                        <textarea maxlength="1000" spellcheck="false"></textarea>
                                                        <div style="height: 40px;padding-top: 10px;">
                                                            <button class="reply-write-button" th:attr="data-id=${comment.id}" onclick="writeReply(this)" style="justify-content: right;">작성</button>
                                                        </div>
                                                    </div>
                                                    <div class="auth-box" th:if="${!auth}">
                                                        <a href="/login">로그인</a>후 이용해 주세요
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="reply-shower" th:attr="data-id=${comment.id}, data-next-page=${comment.totalReply == 0 ? 'none' : '1'}" onclick="showMoreReplies(this)">댓글 더 보기</div>
                                        </ul>
                                    </div>
                                </li>
                            </ul>
                        </div>
                    </div>
                    <th:block
                            th:with="
                         totalPage=${page.totalPages},
                         pageNumber=${page.number},
                         pageSize=${page.size},
                         pageIndex=${pageNumber / 10 + 1},
                         startPage=${pageIndex * 10 - 9},
                         hasNextIndex=${totalPage - startPage >= 10},
                         hasPrevIndex=${startPage - 10 >= 1},
                         endPage=${hasNextIndex ? (pageIndex) * 10 : totalPage}"
                    >
                        <div class="paging-cont" th:if="${endPage > startPage}">
                            <button class="prev-page-button page-button" th:if="${hasPrevIndex}" th:onclick="|location.href='/series/epBoards/${board.id}?page=${startPage - 10}'|">&lt;</button>
                            <th:block th:if="${totalPage != 0}" th:each="num : ${#numbers.sequence(startPage,endPage)}">
                                <button class="page-button" th:classappend="${num == pageNumber + 1} ? 'page-on' : _" th:text="${num}" th:attr="data-number=${num}" onclick="fetchComment(this)"></button>
                            </th:block>
                            <button class="next-page-button page-button" th:if="${hasNextIndex}" th:onclick="|location.href='/series/epBoards/${board.id}?page=${endPage + 1}'|">&gt;</button>
                        </div>
                    </th:block>
                </div>
            </div>
        </main>

        <footer>
            <div class="container">
                <div class="nav-list-box">
                    <div class="prev-work-button nav-item-box" th:onclick="|goPrevEpisode(${prevEpisodeNumber})|">
                        <div class="nav-item" th:classappend="${prevEpisodeNumber == null ? 'disable' : _}" >이전 화</div>
                    </div>
                    <div class="comment-button nav-item-box">
                        <div class="nav-item">댓글</div>
                    </div>
                    <a class="work-list-button nav-item-box" th:href="|/series/${seriesId}|">
                        <div class="nav-item">목록</div>
                    </a>
                    <div class="like-button nav-item-box">
                        <div class="nav-item" th:classappend="${likeBoard} ? 'like' : _">좋아요</div>
                    </div>
                    <div class="next-work-button nav-item-box" th:onclick="|goNextEpisode(${nextEpisodeNumber})|">
                        <div class="nav-item" th:classappend="${nextEpisodeNumber == null ? 'disable' : _}" >다음 화</div>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script th:inline="javascript">
            const boardId = [[${board.id}]];
            const seriesId = [[${seriesId}]];
            const commentButton = document.querySelector(".comment-button");
            const likeButton = document.querySelector(".like-button");

            commentButton.addEventListener("click", () => {
                document.body.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'nearest' });
            });

            likeButton.addEventListener("click", () => {
                fetch(`/series/epBoards/${boardId}/like`, {method: 'POST'})
                .then(res => res.json())
                .then(result => {
                    if(result.status === 200) {
                        const likeItem = document.querySelector(".like-button div");
                        likeItem.classList.toggle("like");
                        return;
                    }else if(result.status === 401){
                        alert("로그인 후 이용 가능합니다.");
                    }else{
                        alert("서버 오류입니다.");
                    }
                })
            });

            function goPrevEpisode(episodeNumber) {
                if(boardId) {
                    const urlParams = new URL(location.href).searchParams;
                    const no = parseInt(urlParams.get('no'));
                    location.href = `/board/episode?no=${episodeNumber}`;
                }else{
                    alert("첫 에피소드입니다.");
                }
            }

            function goNextEpisode(episodeNumber) {
                if(boardId) {
                    const urlParams = new URL(location.href).searchParams;
                    const no = parseInt(urlParams.get('no'));
                    location.href = `/board/episode?no=${episodeNumber}`;
                }else{
                    alert("마지막 에피소드입니다.");
                }
            }
        </script>
    <script>

            /**
             * comment 관련
             */

        document.addEventListener('click', unShowModal);
        function unShowModal() { // modal은 display가 none인 것이기 때문에 실제 존재하는 건 하나가 아니라서 무조건 foreach를 돌려야 함
            document.querySelectorAll('.modal').forEach( (modal) => modal.classList.add('none') );
        }

        function showReplies(target) {
            const commentId = target.dataset.id;
            const allReplyBox = document.querySelectorAll(`.reply-list-box`);
            const replyBox = document.querySelector(`.reply-list-box[data-id='${commentId}']`);
            allReplyBox.forEach(box => { if(box !== replyBox) box.classList.add('none') });
            replyBox.classList.toggle('none');
            if(target.dataset.first == "true"){
                target.dataset.first = "false";
                fetchReplies(commentId, 0);
            }
        }

        function showCommentOption(e) {
            e.stopPropagation();
            document.querySelectorAll('.modal').forEach( (modal) => modal.classList.add('none') );
            const commentId = e.target.dataset.id;
            const modal = document.querySelector(`.comment-option-modal[data-id='${commentId}']`);
            modal.classList.toggle('none');
        }

        function deleteComment(target) {
            const yes = confirm('댓글을 삭제하시겠습니까?');
            if(!yes) return;
            const commentId = target.dataset.id;
            fetch(`/series/epBoards/comments/${commentId}`, {method: 'DELETE'})
            .then( res => res.json() )
            .then(result => {
                if(result.status === 200){
                    alert('댓글이 삭제되었습니다.');
                    const comment = document.querySelector(`.comment-item[data-id='${commentId}']`);
                    comment.remove();
                    decreaseTotalComment(result.data.totalReply);
                    decreaseTotalReply(result.data.motherId);
                }else if(result.status === 401){
                    alert('로그인 후 이용가능합니다.');
                }else if(result.status === 403){
                    alert('권한이 없습니다.');
                }else{
                    alert('서버 오류입니다.');
                }
            })
        }

         function showModifier(target) {
            const commentId = target.dataset.id;
            fetch(`/series/epBoards/comments/${commentId}/auth`)
            .then( res => {
                if(res.ok){
                    showModifyBox(commentId);
                }else{
                    alert('권한이 없습니다.');
                }
            })
        }

        function showModifyBox(commentId) {
            const commentSub = document.querySelector(`.comment-item[data-id='${commentId}'] .comment-sub`);
            const commentContent = document.querySelector(`.comment-item[data-id='${commentId}'] .comment-item-content`);
            const commentOption = document.querySelector(`.comment-item[data-id='${commentId}'] .comment-item-option`);
            const modifyBox = document.querySelector(`.comment-item[data-id='${commentId}'] .modify-box`);
            const textarea = document.querySelector(`.comment-item[data-id='${commentId}'] .modify-box textarea`);

            commentSub.classList.toggle('none');
            commentContent.classList.toggle('none');
            commentOption.classList.toggle('none');
            modifyBox.classList.toggle('none');
            textarea.innerText = commentContent.innerText;
        }

        function modifyComment(target) {
            const commentId = target.dataset.id;
            const commentContent = document.querySelector(`.comment-item[data-id='${commentId}'] .comment-item-content`);
            const textarea = document.querySelector(`.comment-item[data-id='${commentId}'] .modify-box textarea`);

            fetch(`/series/epBoards/comments/${commentId}`,{
                method: 'PATCH',
                body: textarea.value
            }).then( res => {
                if(res.ok){
                    commentContent.innerText = textarea.value;
                    showModifyBox(commentId);
                }else{
                    alert('서버 오류입니다.')
                }
            })
        }

        function showMoreReplies(target) {
            const commentId = target.dataset.id;
            const nextPage = target.dataset.nextPage;
            if(nextPage !== "none") fetchReplies(commentId, nextPage);
        }


        function writeComment() {
            const textarea = document.querySelector('.comment-write-area textarea');
            fetch(`/series/epBoards/${boardId}/comment`, {
                method: 'POST',
                body: textarea.value,
            })
            .then(res => res.json())
            .then(result => {
                if(result.status === 200){
                    textarea.value = "";
                    alert('댓글이 등록되었습니다.')
                    const searchParams = new URLSearchParams(location.search);
                    const page = searchParams.get('page');
                    if(page === '1' || !page){
                        createComment(result.data);
                        increaseTotalComment();
                    }
                }else{
                    alert('잘못된 요청입니다.');
                }
            })
        }


        function writeReply(target) {
            const commentId = target.dataset.id;
            const textarea = document.querySelector(`.reply-write-area[data-id='${commentId}'] textarea`);
            fetch(`/series/epBoards/${boardId}/comments/${commentId}/reply`, {
                method: 'POST',
                body: textarea.value
            })
            .then( res => res.json())
            .then(result => {
                if(result.status === 200){
                    textarea.value = "";
                    alert('댓글이 등록되었습니다.')
                    const replyBox = document.querySelector(`.reply-list-box[data-id='${commentId}'] ul`);
                    const replyElement = createReply(commentId, result.data);
                    replyBox.prepend(replyElement);
                    increaseTotalComment();
                    increaseTotalReply(commentId);
                }else{
                    alert('잘못된 요청입니다.');
                }
            })
        }


        function fetchReplies(commentId, nextPage) {
            fetch(`/series/epBoards/${boardId}/comments/${commentId}/replies?page=${nextPage}`)
            .then(res => res.json())
            .then(result => {
                const shower = document.querySelector(`.reply-shower[data-id='${commentId}']`);
                if(result.code == "NO_NEXT"){
                    shower.dataset.nextPage = "none";
                    shower.classList.add = "none";
                }else{
                    const currentPage = parseInt(shower.dataset.nextPage);
                    shower.dataset.nextPage = currentPage + 1;
                }
                result.data.forEach((reply) => {
                    const replyBox = document.querySelector(`.reply-list-box[data-id='${commentId}'] ul`);
                    const writeForm = document.querySelector(`.reply-list-box[data-id='${commentId}'] .reply-write-form`);
                    const replyElement = createReply(commentId, reply)
                    replyBox.insertBefore(replyElement, writeForm);
                });
            })
        }


        function createReply(commentId, reply) {
            const replyId = reply.id;
            const replyElement = document.createElement('li');
            replyElement.classList.add('comment-item' ,'flex')
            replyElement.dataset.id = replyId;
            replyElement.innerHTML = `
            <div class="reply-boundary"></div>
            <div class="reply-item-box">
                <div class="comment-sub" data-id="${replyId}" onclick="showCommentOption(event)">ㆍㆍㆍ</div>
                <div class="comment-option-modal modal none" data-id="${replyId}">
                    <div class="option flex justify-content-center align-items-center" data-id="${replyId}" onclick="showModifier(this)">수정하기</div>
                    <div class="option flex justify-content-center align-items-center" data-id="${replyId}" onclick="deleteComment(this)">삭제하기</div>
                </div>
                <div class="comment-item-writer">${reply.writer}</div>
                <div class="comment-item-date">${reply.createdDate}</div>
                <div class="comment-item-content"></div>
                <div class="modify-box none">
                    <div class="modify-area">
                        <textarea spellcheck="false"></textarea>
                    </div>
                    <div class="flex" style="justify-content: right;">
                        <button class="mod-apply-button" style="justify-content: right;" data-id="${replyId}" onclick="modifyComment(this)">수정</button>
                        <button class="mod-apply-button" style="justify-content: right;" data-id="${replyId}" onclick="showModifier(this)">취소</button>
                    </div>
                </div>
                <div class="comment-item-option flex">
                    <div class="flex grow align-items-center">
                        <div class="comment-item-like like-unlike" data-id="${replyId}" onclick="likeComment(this)">
                            <img src="/img/likeImg.png">
                            <span>${reply.totalLike}</span>
                        </div>
                        <div class="comment-item-unlike like-unlike" data-id="${replyId}" onclick="unlikeComment(this)">
                            <img src="/img/unlikeImg.png">
                            <span>${reply.totalUnlike}</span>
                        </div>
                    </div>
                </div>
            </div>`
            const contentArea = replyElement.querySelector(".comment-item-content");
            contentArea.textContent = reply.content;
            return replyElement;
        }


        function fetchComment(target) {
            fetch(`/series/epBoards/{boardId}/comments?page=${target.dataset.number}`)
            .then(res => res.json())
            .then(result => {
                if(result.status === 200){
                    const commentBox = document.querySelector(`.comment-list-box ul`);
                    commentBox.innerText ='';
                    result.data.forEach(comment => {
                        createComment(comment);
                    });
                }else{
                    alert('서버 오류입니다.');
                }
            });
        }

        function createComment(data) {
            const commentBox = document.querySelector(`.comment-list-box ul`);
            const commentElement = document.createElement('li');
            const commentId = data.id;
            commentElement.classList.add('comment-item')
            commentElement.dataset.id = commentId;
            commentElement.innerHTML = `
                <div class="comment-item-box">
                    <div class="comment-sub" data-id=${commentId} onclick="showCommentOption(event)">ㆍㆍㆍ</div>
                    <div class="comment-option-modal modal none" data-id=${commentId} >
                        <div class="option flex justify-content-center align-items-center" data-id=${commentId} onclick="showModifier(this)">수정하기</div>
                        <div class="option flex justify-content-center align-items-center" data-id=${commentId} onclick="deleteComment(this)">삭제하기</div>
                    </div>
                    <div class="comment-item-writer">${data.writer}</div>
                    <div class="comment-item-date">${data.createdDate}</div>
                    <div class="comment-item-content"></div>
                    <div class="modify-box none">
                        <div class="modify-area">
                            <textarea spellcheck="false"></textarea>
                        </div>
                        <div class="flex" style="justify-content: right;">
                            <button class="mod-apply-button" style="justify-content: right;" data-id=${commentId} onclick="modifyComment(this)">수정</button>
                            <button class="mod-apply-button" style="justify-content: right;" data-id=${commentId} onclick="showModifier(this)">취소</button>
                        </div>
                    </div>
                    <div class="comment-item-option flex">
                        <div class="comment-item-reply" data-id=${commentId} data-first="false" onclick="showReplies(this)">답글 ${data.totalLike}개</div>
                        <div class="flex grow align-items-center" >
                            <div class="comment-item-like like-unlike" data-id="${commentId}" onclick="likeComment(this)">
                                <img src="/img/likeImg.png">
                                <span>${data.totalLike}</span>
                            </div>
                            <div class="comment-item-unlike like-unlike" data-id="${commentId}" onclick="unlikeComment(this)">
                                <img src="/img/unlikeImg.png">
                                <span>${data.totalUnlike}</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="reply-list-box none" data-id=${commentId}>
                    <ul>
                        <div class="reply-write-form flex">
                            <div class="reply-boundary"></div>
                            <div class="reply-write-box grow">
                                <div class="comment-item-writer">${data.writer}</div>
                                <div class="reply-write-area" data-id=${commentId}>
                                    <textarea spellcheck="false"></textarea>
                                    <div style="height: 40px;padding-top: 10px;">
                                        <button class="reply-write-button" data-id=${commentId} onclick="writeReply(this)" style="justify-content: right;">작성</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="reply-shower" data-id=${commentId} data-next-page="none" onclick="showMoreReplies(this)">댓글 더 보기</div>
                    </ul>
                </div>`
            const contentArea = commentElement.querySelector(".comment-item-content");
            contentArea.textContent = data.content;
            commentBox.prepend(commentElement);
        }

        function increaseTotalComment() {
            const totalComment = document.querySelector(`.comment-count`);
            const num = extractNum(totalComment.innerText);
            totalComment.innerText = `총 ${num + 1}개의 댓글`;
        }

        function increaseTotalReply(commentId) {
            const replyShower = document.querySelector(`.comment-item-reply[data-id='${commentId}']`);
            const num = extractNum(replyShower.innerText);
            replyShower.innerText = `답글 ${num + 1}개`;
        }

        function decreaseTotalComment(amount) {
            const totalComment = document.querySelector(`.comment-count`);
            const num = extractNum(totalComment.innerText);
            totalComment.innerText = `총 ${num - amount}개의 댓글`;
        }

        function decreaseTotalReply(commentId) {
            const replyShower = document.querySelector(`.comment-item-reply[data-id='${commentId}']`);
            if(!replyShower) return; // delete시에 reply가 아닌 경우
            const num = extractNum(replyShower.innerText);
            replyShower.innerText = `답글 ${num - 1}개`;
        }

        function extractNum(str) {
            const regex = /[^0-9]/g;
            const result = str.replace(regex, "");
            return parseInt(result);
        }




        function likeComment(target) {
            const commentId = target.dataset.id;
            fetch(`/series/epBoards/comments/${commentId}/like`, {
                method: 'POST'
            })
            .then(res => res.json())
            .then(result => {
                const status = result.status;
                if(status === 200){
                    const totalLike = document.querySelector(`.comment-item-like[data-id='${commentId}'] span`);
                    if(result.code === "INCREASE"){
                        totalLike.innerText = parseInt(totalLike.innerText) + 1;
                    }else{
                        totalLike.innerText = parseInt(totalLike.innerText) - 1;
                    }
                }else if(status === 401){
                    alert('로그인 후 이용해 주세요.');
                    location.href = `/login`;
                }else{
                    alert('서버 오류입니다.');
                }
            })
        }

        function unlikeComment(target) {
            const commentId = target.dataset.id;
            fetch(`/series/epBoards/comments/${commentId}/unlike`, {
                method: 'POST'
            })
            .then(res => res.json())
            .then(result => {
                const status = result.status;
                if(status === 200){
                    const totalUnlike = document.querySelector(`.comment-item-unlike[data-id='${commentId}'] span`);
                    if(result.code === "INCREASE"){
                        totalUnlike.innerText = parseInt(totalUnlike.innerText) + 1;
                    }else{
                        totalUnlike.innerText = parseInt(totalUnlike.innerText) - 1;
                    }
                }else if(status === 401){
                    alert('로그인 후 이용해 주세요.');
                    location.href = `/login`;
                }else{
                    alert('서버 오류입니다.');
                }
            })
        }



        </script>

    <script  th:inline="javascript">

            const work = [[${episode}]];

            const audioCtx = new AudioContext();

            let isPlaying = false;

            const bgSounds = work.bgSounds;
            const bgSoundNodeMap = new Map();
            let bgSoundNumberCount = 0;
            let bgSoundReady = false;
            class BgSoundNode {
                soundNumber;
                sourceNode;
                audioBuffer;
                startSceneNumber;
                endSceneNumber;
                startTime = 0;
                startOffset = 0;
                isPlaying = false;
                constructor(soundNumber, audioBuffer, startScene, endScene) {
                    this.soundNumber = soundNumber;
                    this.audioBuffer = audioBuffer;
                    this.startSceneNumber = startScene;
                    this.endSceneNumber = endScene;
                }

                startSound() {
                    const node = audioCtx.createBufferSource();
                    node.buffer = this.audioBuffer;
                    node.connect(audioCtx.destination);
                    node.start(0, this.startOffset);
                    this.startTime = Date.now();
                    this.sourceNode = node;
                }

                stopSound() {
                    if(this.sourceNode) this.sourceNode.stop();
                    this.startOffset = (Date.now() - this.startTime) / 1000;
                }
            }

            /**
             * Scene Option
             */
            const showerBox = document.querySelector(".shower-box");
            const prevSceneButton = document.querySelector(".prev-scene-button");
            const nextSceneButton = document.querySelector(".next-scene-button");

            const scenes = work.scenes;
            const totalScenes = scenes.length;
            const sceneNodeMap = new Map();
            let currentSceneAudio;

            let readyToPlay = false;
            let sceneReadyCount = 0;
            let sceneCount = 1;
            let sceneTimeout;

            class SceneNode {
                layers;
                audioBuffer;
                sceneNumber;
                constructor(layers, audioBuffer, sceneNumber) {
                    this.layers = layers;
                    this.audioBuffer = audioBuffer;
                    this.sceneNumber = sceneNumber;
                }
            }

            prevSceneButton.addEventListener("click", (e) => {
                e.stopPropagation();

                // autoMode가 수행 중일 때와 아닐 때로 분기 처리
                if (isPlaying) {
                    if (sceneCount - 1 >= 1) {
                        sceneCount--;
                    }
                    playWork();
                } else {
                    const currentScene = sceneNodeMap.get(sceneCount);

                    if (layerCount > 1) {
                        // 현재 장면의 레이어들 중 이전 레이어로 넘어감
                        showerBox.innerHTML = "";
                        showerBox.append(
                            currentScene.layers[--layerCount - 1]
                                .imgElement
                        );
                    } else if (!(sceneCount - 1 < 1)) {
                        // 레이어가 1이면서 이전 장면이 있는 경우 이전 장면으로 넘어감
                        sceneCount--;
                        const nextScene = sceneNodeMap.get(sceneCount);
                        layerCount = nextScene.layers.length;
                        showerBox.innerHTML = "";
                        showerBox.append(
                            nextScene.layers[layerCount - 1].imgElement
                        );
                    }
                }
            });

            nextSceneButton.addEventListener("click", (e) => {
                e.stopPropagation();

                // autoMode가 수행 중일 때와 아닐 때로 분기 처리
                if (isPlaying) {
                    if (sceneCount + 1 <= scenes.length) {
                        sceneCount++;
                    }
                    playWork();
                } else {
                    const currentScene = sceneNodeMap.get(sceneCount);
                    if (currentScene.layers.length > layerCount) { // 현재 layer가 장면의 전체 레이어 보다 작은 경우(다음 레이어로 이동)
                        showerBox.innerHTML = "";
                        showerBox.append(
                            currentScene.layers[++layerCount - 1]
                                .imgElement
                        );
                    } else if (!(sceneCount + 1 > scenes.length)) { //현재 Layer가 장면의 전체 레이어 수 보다 크거나 같고 다음 장면이 존재하는 경우
                        layerCount = 1;
                        sceneCount++;
                        const nextScene = sceneNodeMap.get(sceneCount);
                        showerBox.innerHTML = "";
                        showerBox.append(
                            nextScene.layers[layerCount - 1].imgElement
                        );
                    }
                }
            });

            let layerCount = 1;
            let layerTimeout;

            class LayerNode {
                imgElement;
                duration;
                startTime;
                endTime;
                constructor(imgElement, duration, startTime) {
                    this.imgElement = imgElement;
                    this.duration = duration;
                    this.startTime = startTime;
                    this.endTime = startTime + duration;
                }
            }

            initSceneData();
            async function initSceneData() {
                setTimeout(checkReadyToPlay, 200);
                for (let i = 0; i < bgSounds.length; i++) {
                    const bgSound = bgSounds[i];
                    await createBgSoundNode(bgSound);
                }
                bgSoundReady = true;

                for (let i = 0; i < scenes.length; i++) {
                    const scene = scenes[i];
                    const layerNodes = await createLayerNode(scene);
                    await createSceneNode(scene, layerNodes);
                    sceneReadyCount++;
                }
            }

            async function createLayerNode(scene) {
                const layerNodes = [];
                let totalLayerDuration = 0;
                const layers = scene.layers;
                for (let i = 0; i < layers.length; i++) {
                    // forEach문은 동기실행이 안 되기 때문에 비동기를 위해 for문 사용
                    const layer = layers[i];
                    if (layer.imgFileUrl) {
                        const imageObject = new Image();
                        imageObject.classList.add("shower");
                        const layerNode = await (async function loadImage() {
                            imageObject.src = layer.imgFileUrl;
                            return new Promise((resolve) => {
                                imageObject.onload = function () {
                                    const layerNode = new LayerNode(
                                        imageObject,
                                        layer.duration,
                                        totalLayerDuration
                                    );
                                    totalLayerDuration += layer.duration;
                                    showerBox.append(imageObject);
                                    layerNodes.push(layerNode);
                                    resolve();
                                };
                            });
                        })();
                    } else {
                        const div = document.createElement("div");
                        div.classList.add("shower");
                        const layerNode = new LayerNode(
                            div,
                            layer.duration,
                            totalLayerDuration
                        );
                        totalLayerDuration += layer.duration;
                        showerBox.append(div);
                        layerNodes.push(layerNode);
                    }
                }
                return layerNodes;
            }

            function createBgSoundNode(bgSound) {
                if (!bgSound.audioFileUrl) return;

                return new Promise(async (resolve) => {
                    const blob = await fetch(bgSound.audioFileUrl).then((r) =>
                        r.blob()
                    );
                    const fileReader = new FileReader();
                    fileReader.readAsArrayBuffer(blob);
                    fileReader.onload = async function () {
                        const arrayBuffer = fileReader.result;
                        if (arrayBuffer instanceof ArrayBuffer) {
                            const audioBuffer = await audioCtx.decodeAudioData(
                                arrayBuffer
                            ); // 이 메소드는 MP3와 WAV 확장자에만 가능하다는 듯 하다.
                            const bgSoundNode = new BgSoundNode(
                                ++bgSoundNumberCount,
                                audioBuffer,
                                bgSound.startSceneNumber,
                                bgSound.endSceneNumber
                            );
                            bgSoundNodeMap.set(
                                bgSoundNode.soundNumber,
                                bgSoundNode
                            );
                            resolve();
                        }
                    };
                });
            }

            function createSceneNode(scene, layerNodes) {
                if (scene.audioFileUrl) {
                    return new Promise((resolve) => {
                    fetch(scene.audioFileUrl)
                        .then((r) => r.blob())
                        .then((blob) => {
                            const fileReader = new FileReader();
                            fileReader.readAsArrayBuffer(blob);
                            const audioBuffer = (fileReader.onload =
                                async function () {
                                    const arrayBuffer = fileReader.result;
                                    if (arrayBuffer instanceof ArrayBuffer) {
                                        const audioBuffer =
                                            await audioCtx.decodeAudioData(
                                                arrayBuffer
                                            ); // 이 메소드는 MP3와 WAV 확장자에만 가능하다는 듯 하다.
                                        const sceneNode = new SceneNode(
                                            layerNodes,
                                            audioBuffer,
                                            scene.sceneNumber
                                        );
                                        sceneNodeMap.set(
                                            sceneNode.sceneNumber,
                                            sceneNode
                                        );
                                        resolve();
                                    }
                                });
                        });
                    });
                }else{
                    const sceneNode = new SceneNode(
                        layerNodes,
                        null,
                        scene.sceneNumber
                    );
                    sceneNodeMap.set(
                        sceneNode.sceneNumber,
                        sceneNode
                    );
                    return;
                }
            }

            function checkReadyToPlay() {
                if (sceneReadyCount > scenes.length / 2 && bgSoundReady)
                    readyToPlay = true;
                else setTimeout(checkReadyToPlay, 200);
            }

            async function playWork() {
                if (!readyToPlay) return;

                layerCount = 1;
                isPlaying = true;

                stopPrevBgSounds();
                playBgSounds();

                for (; sceneCount <= scenes.length; sceneCount++) {
                    if (!isPlaying) return;
                    const scene = sceneNodeMap.get(sceneCount);
                    await playScene(scene);
                }

                // sceneCount는 for문을 돌리고 있기 때문에 마지막에 sceneCount가 1이 증가된 상태이므로 다시 감소시켜야 함
                sceneCount--;

                changePlayingState();
            }

            function stopPrevBgSounds(params) {
                bgSoundNodeMap.forEach((bgSound) => {
                    if (bgSound.sourceNode) bgSound.sourceNode.stop();
                    if(bgSound.isPlaying)  bgSound.isPlaying = false;
                });
            }

            function playBgSounds() {
                // 플레이할 Background Sound를 계산
                const bgSoundNodes = [];
                bgSoundNodeMap.forEach((bgSound) => {
                    if (
                        bgSound.startSceneNumber <= sceneCount &&
                        bgSound.endSceneNumber >= sceneCount &&
                        bgSound.startSceneNumber <= scenes.length
                    ) {
                        bgSoundNodes.push(bgSound);
                    }
                });

                // 플레이할 Background Sound의 startOffset을 계산
                bgSoundNodes.forEach((bgSound) => {
                    let totalDuration = 0;
                    for (let i = bgSound.startSceneNumber; i < sceneCount; i++) {
                        const sceneNode = sceneNodeMap.get(i);
                        sceneNode.layers.forEach((layer) => {
                            totalDuration += layer.endTime - layer.startTime;
                        });
                    }
                    bgSound.startOffset = totalDuration;
                });

                bgSoundNodes.forEach((bgSound) => {
                    bgSound.isPlaying = true;
                    bgSound.startSound();
                });
            }

            function playScene(scene) {
                if (!readyToPlay) return;

                // 기존의 레이어 timeout을 제거해야 함 (자동 재생 상태에서 button을 통해 이전, 다음 장면으로 넘어갈 경우 timeout이 중첩되는 것을 방지)
                clearTimeout(layerTimeout);

                stopCurrentSceneBgSound();
                playCurrentSceneBgSound();

                const sourceNode = audioCtx.createBufferSource();
                if (currentSceneAudio) currentSceneAudio.stop();

                if(scene.audioBuffer){
                    sourceNode.buffer = scene.audioBuffer;
                    sourceNode.connect(audioCtx.destination);
                    sourceNode.start(0, 0);
                    currentSceneAudio = sourceNode;
                }

                return new Promise((resolve) => {
                    setLayerTimeout(resolve, scene);
                });
            }

            function playCurrentSceneBgSound() {
                bgSoundNodeMap.forEach((bgSound) => {
                    if (
                        bgSound.startSceneNumber === sceneCount &&
                        bgSound.isPlaying === false
                    )
                        bgSound.startSound();
                });
            }

            function stopCurrentSceneBgSound() {
                bgSoundNodeMap.forEach((bgSound) => {
                    if (
                        bgSound.endSceneNumber === sceneCount - 1 &&
                        bgSound.isPlaying === true
                    )
                        bgSound.stopSound();
                });
            }

            function setLayerTimeout(resolve, scene) {
                if (layerCount > scene.layers.length) {
                    if(scene.sceneNumber < totalScenes)
                        layerCount = 1
                    else
                        layerCount--; // 마지막 장면일 경우에는 장면이 멈추기 때문에 올라간 layerCount 하나 내리고 그대로 둠
                    resolve();
                    return;
                }
                const layer = scene.layers[layerCount - 1];
                showerBox.textContent = ``;
                showerBox.append(layer.imgElement);
                const timeout = layer.duration;
                layerTimeout = setTimeout(() => {
                    switchLayer(resolve, scene);
                }, timeout * 1000);
            }
            function switchLayer(resolve, scene) {
                layerCount++;
                setLayerTimeout(resolve, scene);
            }
        </script>
    <script>

            let viewMode = "VERTICAL";

            const showerCont = document.querySelector(".shower-cont");

            const header = document.querySelector("header");
            const footer = document.querySelector("footer");

            const viewModeButton = document.querySelector(".view-mode-changer");
            const autoModeButton = document.querySelector(".auto-mode-changer");
            const viewModeSpan = document.querySelector(
                ".view-mode-changer span"
            );
            const autoModeSpan = document.querySelector(
                ".auto-mode-changer span"
            );
            const autoModeImg = document.querySelector(
                ".auto-mode-changer img"
            );

            showerCont.addEventListener("click", () =>
                header.classList.toggle("none")
            );
            showerCont.addEventListener("click", () =>
                footer.classList.toggle("none")
            );

            header.addEventListener("click", (e) => e.stopPropagation());
            footer.addEventListener("click", (e) => e.stopPropagation());
            autoModeButton.addEventListener("click", (e) => {
                changePlayingState();
            });

            function changePlayingState() {
                if(!work.autoMode) {
                    alert("자동재생을 지원하지 않는 작품입니다.");
                    return;
                }

                if (isPlaying) {
                    isPlaying = false;
                    if (layerTimeout) clearTimeout(layerTimeout);
                    if (currentSceneAudio) currentSceneAudio.stop();
                    stopPrevBgSounds();
                    autoModeSpan.textContent = "재생하기";
                    autoModeImg.src = "/img/viewer/playButton.png";
                } else {
                    if (!readyToPlay) return;
                    playWork();
                    autoModeSpan.textContent = "멈추기";
                    autoModeImg.src = "/img/viewer/stopButton.png";
                }
            }

            let viewModeChanging = false;
            viewModeButton.addEventListener("click", () => {
                if (!readyToPlay) {
                    alert("이미지 로딩중입니다. 잠시 후 다시 시도해 주세요");
                    return;
                }

                if(viewModeChanging) return; // 이미 변경중일 경우 취소

                if(isPlaying) changePlayingState(); // viewMode를 전환할 때, 기존에 풀레이 중인 상태를 모두 초기화 해야 함

                // 변경 시작
                viewModeChanging = true;

                // 상단 바 변경
                autoModeButton.classList.toggle("none");
                prevSceneButton.classList.toggle("none");
                nextSceneButton.classList.toggle("none");
                viewModeSpan.textContent = viewMode === "VERTICAL" ? "가로모드" : "세로모드";

                // body부분 변경
                changeViewMode();

                // 변수 설정
                viewMode = viewMode === "VERTICAL" ? "HORIZON" : "VERTICAL";
                viewModeChanging = false;
            });

            function changeViewMode() {
                if (viewMode === "HORIZON") { // 현재 상태가 가로 모드이면 -> 세로 모드로
                    showerBox.innerHTML = "";
                    showerBox.classList.add('vert-mode');
                    for (let i = 1; i <= scenes.length; i++) {
                        const sceneNode = sceneNodeMap.get(i);
                        for (let j = 0; j < sceneNode.layers.length; j++) {
                            const layer = sceneNode.layers[j];
                            showerBox.append(layer.imgElement);
                        }
                    }
                } else { // 현재 상태가 세로 모드이면 -> 가로 모드로
                    showerBox.innerHTML = "";
                    showerBox.classList.remove('vert-mode');
                    const sceneNode = sceneNodeMap.get(sceneCount);
                    showerBox.append(sceneNode.layers[0].imgElement);
                }
            }
        </script>
</body>
</html>